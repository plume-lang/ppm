require "char"

type ParserResult<A> { Result(Result<str, A>, str) }

type Parser<A> { Parser(fn(str): ParserResult<A>) }

extend (c: str) {
  fn extract_head(): (Option<char>, str) => (c[0], c[1..])
}

extend<A> (r: ParserResult<A>) {
  fn map<B>(f: fn (A): B): ParserResult<B> =>
    switch r {
      case Result(r, rest) => Result(r.map(f), rest)
    }
}

extend<A> (p: Parser<A>) {
  fn run_parser(input: str): ParserResult<A> =>
    switch p {
      case Parser(f) => f(input)
      case ? => Result(Error("Should not happen"), "")
    }

  fn eval_parser(input: str): Result<str, A> =>
    switch p.run_parser(input) {
      case Result(res, rest) => res
      case ? => Error("Should not happen")
    }
}

fn throw_parser(err: str): Parser<A> => 
  Parser(fn (input) => Result(Error(err), input))

fn throw_result<A>(err: str): ParserResult<A> => 
  Result(Error(err), "")

fn pure<A>(x: A): Parser<A> =>
  Parser(fn (input) => Result(Ok(x), input))

extend<A> (p: Parser<A>) {
  fn and_then<B>(f: fn (A): Parser<B>): Parser<B> =>
    Parser(fn (input) => switch p.run_parser(input) {
      case Result(Ok(result), rest) => f(result).run_parser(rest)
      case Result(Error(err), ?) => Result(Error(err), "")
    })

  fn map<B>(f: fn (A): B): Parser<B> =>
    Parser(fn (input) => p.run_parser(input).map(f))
}

infixr 3 >>
infixr 2 >>=

extend<A> (p: Parser<A>) {
  fn (>>) <B>(q: Parser<B>): Parser<B> => p.and_then(fn (_) => q)

  fn (>>=) <B>(f: fn (A): Parser<B>): Parser<B> => p.and_then(f)
}

fn satisfy(predicate: fn (char): bool): Parser<char> =>
  Parser(fn (input) => 
    switch input.extract_head() {
      case (Some(x), xs) => 
        if predicate(x) { 
          return Result(Ok(x), xs) 
        } else {
          return Result(Error("Unexpected input"), input)
        }
      case (None, ?) => Result(Error("Unexpected end of input"), "")
    })

fn character(c: char): Parser<char> =>
  Parser(fn (input) => switch input.extract_head() {
      case (Some(x), xs) => 
        if x == c { 
          return Result(Ok(x), xs) 
        } else {
          return Result(Error("Unexpected input"), input)
        }
      case (None, ?) => Result(Error("Unexpected end of input"), "")
  })

fn string(s: str): Parser<str> =>
  switch s.extract_head() {
    case (Some(x), xs) => character(x)
      .and_then(fn (_) => string(xs))
      .and_then(fn (_) => pure(s))
    case (None, ?) => pure("")
  }

extend<A> (p: Parser<A>) {
  fn or(q: Parser<A>): Parser<A> =>
    Parser(fn (input) => switch p.run_parser(input) {
      case Result(Ok(result), rest) => Result(Ok(result), rest)
      case Result(Error(?), ?) => q.run_parser(input)
    })

  fn many(): Parser<[A]> =>
    (p >>= fn (x) => Parser(fn (input) =>
      switch p.many().run_parser(input) {
        case Result(Ok(xs), rest) => Result(Ok(xs.prepend(x)), rest)
        case Result(Error(?), ?) => Result(Ok([x]), input)
      })
    ) or pure([])

  fn many1(): Parser<[A]> => p >>= fn (x) => 
    p.many() >>= fn (xs) => pure(xs.prepend(x))
}

fn clist_to_str(xs: [char]): str => 
  switch xs {
    case [] => ""
    case [x, ..xs] => x.to_str() + xs.clist_to_str()
  }

alphabetic: Parser<char> = satisfy(is_alphabetic)

identifier: Parser<str> = alphabetic >>= fn (x) =>
  alphabetic.many() >>= fn (xs) =>
    pure(x.to_str() + xs.clist_to_str())

spaces: Parser<()> = satisfy(is_whitespace).many() >> pure(unit)

fn choice<A>(ps: [Parser<A>]): Parser<A> =>
  switch ps {
    case [] => throw_parser("No parser left to choose from")
    case [p, ..ps] => p.or(choice(ps))
  }

fn sep_by<A, B>(p: Parser<A>, sep: Parser<B>): Parser<[A]> =>
  (p >>= fn (x) => (sep >> p).many() >>= fn (xs) => pure(xs.prepend(x))) 
    or pure([])

infixr 3 <?>

extend<A> (p: Parser<A>) {
  fn (<?>) (msg: str): Parser<A> =>
    Parser(fn (input) => switch p.run_parser(input) {
      case Result(Ok(?), ?) => p.run_parser(input)
      case Result(Error(?), ?) => Result(Error(msg), input)
    })
}

fn optional<A>(p: Parser<A>): Parser<Option<A>> => p.map(Some).or(pure(None))