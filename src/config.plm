require "pretty"

type Value { 
  Version([int]),
  String(str)
}

type Rule { Rule(str, Value) }

extend equality<Value> {
  fn (==) (a, b) => switch (a, b) {
    case (Version(v1), Version(v2)) => v1 == v2
    case (String(s1), String(s2)) => s1 == s2
    case ? => false
  }
}

extend show<Value> {
  fn show_prec(v, _) => switch v {
    case Version(vs) => vs.map(show).join_str(".")
    case String(s) => s
  }
}

extend equality<Rule> {
  fn (==) (a, b) => switch (a, b) {
    case (Rule(x1, s1), Rule(x2, s2)) => x1 == x2 and s1 == s2
  }
}

extend show<Rule> {
  fn show_prec(r, _) => switch r {
    case Rule(x, s) => x + " = " + s.show()
  }
}

extend monoidal<Value> {
  fn empty() => String("")
  fn concat(a, b) => switch (a, b) {
    case (String(s1), String(s2)) => String(s1 + s2)
    case (Version(v1), Version(v2)) => Version(v1 + v2)
    case ? => String("")
  }
}

version = digit
  .map(fn (d) => ffi_to_int([d].implode()))
  .sepBy1(character('.'))
  .map(Version)

st = none_of(['\n', '\r']).many().map(fn (ds) => String(ds.implode()))

value = version or st

rule = identifier.lex() >>= fn (id) => 
  character('=') >> value.lex() >>= fn (val) =>
    pure(Rule(id.implode(), val))

config_parser = rule.sepBy(newline)

type Config = list<Rule>

fn parse_config(content: str): Config => switch config_parser.parse(content.explode()) {
  case Some(cs) => cs
  case None => []
}

fn get_rule(config: Config, key: str): Option<Value> =>
  config.foldl(fn(acc, rl) => switch rl {
    case Rule(k, v) => if k == key { return Some(v) } else { return acc }
  }, None)
  
fn print_config(path: str) {
  result = await read_file("ppm.config")
  switch result {
    case Some(_content) {
      content = _content.explode()
      res = config_parser.parse(content)

      switch res {
        case Some(cs) {
          fmt = cs.map(show).unlines()
          println(fmt)
        }

        case None {  }
      }
    }
    
    case None => error("File not found")
  }
}

cwd = get_cwd().or_else(".")
file_config = switch await read_file("$cwd/ppm.config") {
  case Some(content) => parse_config(content)
  case None => []
}

fn seq_opt_async<T>(x: Option<async<T>>): async<Option<T>> {
  return switch x {
    case Some(a) {
      res = await a

      return Some(res).async()
    }
    case None => None.async()
  }
}

fn get_string(config: Config, key: str): Option<str> {
  return switch get_rule(config, key) {
    case Some(String(s)) => Some(s)
    case ? => None
  }
}

fn read_config(path: str): Option<Config> {
  result = await read_file(path)
  return switch result {
    case Some(content) => Some(parse_config(content))
    case None => None
  }
}

ppm_path = get_env("PPM_PATH")
ppm_config = switch ppm_path {
  case Some(path) => await read_config("$path/ppm.config")
  case None => None
}