type Value { 
  Version([int]),
  String(str)
}

type Rule { Rule(str, Value) }

extend equality<Value> {
  fn (==) (a, b) => switch (a, b) {
    case (Version(v1), Version(v2)) => v1 == v2
    case (String(s1), String(s2)) => s1 == s2
    case ? => false
  }
}

extend show<Value> {
  fn show(v) => switch v {
    case Version(vs) => vs.map(show).join(".")
    case String(s) => s
  }
}

extend equality<Rule> {
  fn (==) (a, b) => switch (a, b) {
    case (Rule(x1, s1), Rule(x2, s2)) => x1 == x2 and s1 == s2
  }
}

extend show<Rule> {
  fn show(r) => switch r {
    case Rule(x, s) => x + " = " + s.show()
  }
}

extend monoidal<Value> {
  fn empty() => String("")
  fn concat(a, b) => switch (a, b) {
    case (String(s1), String(s2)) => String(s1 + s2)
    case (Version(v1), Version(v2)) => Version(v1 + v2)
    case ? => String("")
  }
}

version = digit
  .map(fn (d) => ffi_to_int([d].implode()))
  .sepBy1(character('.'))
  .map(Version)

st = none_of(['\n', '\r']).many().map(fn (ds) => String(ds.implode()))

value = version or st

rule = identifier.lex() >>= fn (id) => 
  character('=') >> value.lex() >>= fn (val) =>
    pure(Rule(id.implode(), val))

config_parser = rule.sepBy(newline)

type Config = list<Rule>

fn parse_config(content: str): Config => switch config_parser.parse(content.explode()) {
  case Some(cs) => cs
  case None => []
}

fn get_rule(config: Config, key: str): Option<Value> =>
  config.foldl(fn(acc, rl) => switch rl {
    case Rule(k, v) => if k == key { Some(v) } else { acc }
  }, None)
  
fn print_config(path: str) {
  result = read_file("ppm.config")
  switch result {
    case Some(_content) {
      content = _content.explode()
      res = config_parser.parse(content)

      switch res {
        case Some(cs) {
          fmt = cs.map(show).unlines()
          println(fmt)
        }

        case None {  }
      }
    }
    
    case None => {
      println("No content found in file")

      unit
    }
  }
}